<!DOCTYPE html>
<html>
<head>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .wave-container {
      width: 100vw;
      height: 100vh;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wave {
      width: 100%;
      height: 400px;
      position: relative;
      cursor: pointer;
    }

    .wave-line {
      stroke: #000;
      stroke-width: 2;
      fill: none;
    }
  </style>
</head>
<body>
  <div class="wave-container">
    <svg class="wave" viewBox="0 0 1000 400" preserveAspectRatio="none">
      <path class="wave-line" id="wavePath" />
    </svg>
  </div>

  <script>
    const wavePath = document.getElementById('wavePath');
    const wave = document.querySelector('.wave');
    let isAnimating = false;
    let mouseHistory = [];
    let basePhase = 0;
    const staticWaves = [];

    // Create static waves with random properties for chaotic movement
    for (let i = 0; i < 5; i++) {
      staticWaves.push({
        frequency: Math.random() * 0.05 + 0.02,
        amplitude: Math.random() * 20 + 10,
        phase: Math.random() * Math.PI * 2,
      });
    }

    function updateWave(mouseX, mouseY) {
      const rect = wave.getBoundingClientRect();
      const newX = ((mouseX - rect.left) / rect.width) * 1000;

      mouseHistory.unshift({ x: newX, amplitude: 80, phase: 0 });
      if (mouseHistory.length > 10) mouseHistory.pop();

      if (!isAnimating) {
        animateWave();
      }
    }

    function animateWave() {
      isAnimating = true;

      function animate() {
        basePhase += 0.05;
        const points = [];

        staticWaves.forEach(wave => {
          wave.phase += 0.02; // Dynamic phases for static waves
        });

        mouseHistory.forEach(point => {
          point.phase += 0.1;
          point.amplitude *= 0.9;
        });
        mouseHistory = mouseHistory.filter(point => point.amplitude > 1);

        for (let i = 0; i <= 1000; i += 2) {
          let y = 200;

          staticWaves.forEach(wave => {
            y += Math.sin(basePhase * wave.frequency + i * wave.frequency + wave.phase) * wave.amplitude;
          });

          mouseHistory.forEach(point => {
            const distance = Math.abs(i - point.x);
            const influence = Math.exp(-distance * 0.01) * point.amplitude;
            const waveEffect = Math.sin(distance * 0.05 - point.phase) * influence;
            y += waveEffect;
          });

          points.push([i, y]);
        }

        let d = `M${points[0][0]},${points[0][1]}`;
        for (let i = 1; i < points.length - 2; i += 1) {
          const xc = (points[i][0] + points[i + 1][0]) / 2;
          const yc = (points[i][1] + points[i + 1][1]) / 2;
          d += ` Q${points[i][0]},${points[i][1]} ${xc},${yc}`;
        }

        wavePath.setAttribute('d', d);

        if (mouseHistory.length > 0 || Math.abs(basePhase) > 0.01) {
          requestAnimationFrame(animate);
        } else {
          isAnimating = false;
        }
      }

      animate();
    }

    animateWave();

    wave.addEventListener('mousemove', (e) => {
      updateWave(e.clientX, e.clientY);
    });

    wave.addEventListener('click', (e) => {
      const rect = wave.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 1000;
      mouseHistory.push({ x: x, amplitude: 100, phase: 0 });
      if (!isAnimating) {
        animateWave();
      }
    });

    wave.addEventListener('mouseleave', () => {
      mouseHistory.forEach(point => point.amplitude *= 0.7);
    });
  </script>
</body>
</html>
